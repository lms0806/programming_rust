# 러스트 둘러보기
## rustup과 카고
  - 러스트는 언어의 각 부분이 전체의 맥락 안에 있을 때 최고의 존재 가치를 발휘한다.
  - 미정의 동작을 방지하면서도 성능에 미치는 영향은 최소화하겠다는 러스트의 약속은 벡터와 문자열 같은 표준 데이터 구조에서부터 프로그램이 서드파티 라이브러리를 사용하는 방식에 이르기까지 전체적인 시스템 설계에 전방위적인 영향을 미친다.
  - cargo
    - 러스트의 컴파일 관리자이자 패키지 관리자이며, 다양한 쓰임새를 가진 도구다.
    - 새 프로젝트를 시작하고, 프로그램을 빌드해 실행하고, 코드가 의존하는 외부 라이브러리를 관리하기 위한 용도로 쓰인다.
  - rustc
    - 러스트 컴파일러다.
    - 보통 카고를 통해 실행하지만, 가끔은 직접 실행해야 할 때도 있다.
  - rustdoc
    - 러스트 문서화 도구다.
    - 프로그램의 소스코드에 적절한 형식의 주석으로 문서를 작성해두면 이를 가지고 깔끔하게 정리된 HTML 문서를 만들어준다.
    - rustc처럼 보통은 카고를 통해 실행한다.
  - hello라는 이름의 새 패키지 디렉터리를 만듬
 ```
    cargo new hello
 ```
  - 카고가 러스트 컴파일러인 rustc로 패키지를 컴파일한 다음, 만들어진 실행 파일을 실행시켜 준다.
  - 실행 파일은 패키지의 최상위에 있는 target 디렉터리에 만들어진다.
 ```
    cargo run
 ```

## 러스트 함수
  - 러스트의 머신 정수 타입은 이름에 크기와 부호의 유무가 반영되어 있다.
  - 기본적으로 변수는 한 번 초기화되고 나면 그 값을 바꿀 수 없다. 그러나, 매개변수 앞에 mut 키워드(mutable의 준말)를 붙이면 함수 본문에서 이들에게 값을 배정할 수 있게 된다.
  - 러스트는 프로그램이 어떻게 컴파일 되었든 상관없이 항상 단언문을 검사한다.
  - 러스트는 변수의 쓰임새에서 타입을 추론할 수 있다.
  - 함수 본문이 세미콜론으로 끝나지 않는 표현식으로 마치면, 그것이 함수의 반환값이 된다.

## 단위 테스트 작성해 돌려보기
  - #[test]는 어트리뷰트의 한 예로 해당 함수가 테스트 함수라는 걸 나타낸다.
  - 어트리뷰트는 함수와 기타 다른 선언에 추가 정보를 표시하기 위한 개방형 시스템으로, C++와 C#의 어트리뷰트나 자바의 애너테이션과 같다고 보면 된다.
  - cargo test는 이들이 어디에 있든 상관없이 알아서 전부 모아 실행시켜 준다.
 ```
    cargo test
 ```

## 명령줄 인수 다루기
  - use 선언문은 표준 라이브러리의 트레이트 FromStr를 범위 안으로 가져온다.
  - 트레이트는 타입이 구현할 수 있는 메서드 모음이다.
 - FromStr 트레이트를 구현하는 모든 타입은 문자열을 해당 타입의 값으로 파싱하는 from_str 메서드를 갖는다.
  - Vec는 러스트의 벡터 타입으로 C++의 std::vector, 파이썬의 리스트, 자바스크립트의 배열과 비슷하다. 벡터는 크기가 동적으로 늘고 줄게 되어 있지만, 변수 앞에 mut를 붙이지 않으면그 안에 아무것도 넣을 수 없다.
  - std::env 모듈의 args 함수는 이터레이터를 반환한다. 이 이터레이터는 요구가 있을 때마다 인수를 하나씩 반환하고, 더 이상 반환할 게 없을 때는 없음을 나타내는 값을 반환한다.
  - Result 값은 다음의 두 베리언트(variant) 중 하나다.
    - Ok(V)라고 쓰는 값. 파싱이 성공했음을 나타내며, v는 그 결과값이다.
    - Err(e)라고 쓰는 값. 파싱이 실패했음을 나타내며, e는 그 이유를 설명하는 오류값이다.
  - 입출력을 수행하거나 운영체제와 상호 작용하는 것처럼 실패할 수도 있는 일을 하는 함수들은 Result 타입을 반환할 수 있는데, 이 때 Ok 베리언트는 전송한 바이트 수나 열린 파일 등과 같은 성공한 결과를 전달하고, Err 베리언트는 무엇이 잘못되었는지를 나타내는 오류 코드를 전달한다.
  - expect는 결과가 Err(e)일 경우 e에 대한 설명이 포함된 메시지를 출력한 뒤 프로그램을 곧바로 종료하지만, 결과가 Ok(v)일 경우에는 단순히 v 자체를 반환하기 때문에 최종적으로 numbers에 넣을 수 있는 값을 얻게 된다.
  - eprintln! 매크로를 써서 표준 오류 출력 스트림에 오류 메시지를 기록한다.
  - 크기가 고정되어 있지 않은 값을 다룰 떄는 그 안에 개별 값의 수명을 확실히 못박아서, 더 이상 필요치 않은 메모리가 지체없이 해제될 수 있게 만들어야 한다. 그래야 프로그래머가 메모리 소모량을 통제할 수 있다.
  - 반복 처리를 진행할 때 러스트에게 벡터의 소유권(ownership)이 계속해서 numbers에 남아 있어야 한다고 알린다.즉, 루프를 위해서 벡터의 요소를 잠시 빌려오기(borrowing)만 하는 것이다.
  - & 연산자는 요소들에 대한 레퍼런스(reference)를 빌려온다.
  - * 연산자는 역참조(dereference)해서 그것이 가리키는 값을 넘겨준다.
  - 프로그램이 정상 종료됐다면 0을, 그렇지 않고 뭔가 틀어졌으면 0이 아닌 종료 상태를 반환하게 되어 C와 C++의 main과 달리, 러스트는 main이 아무것도 반환하지 않으면 프로그램이 정상종료 된 것으로 간주한다.
  - expect나 std::process::exit 같은 함수를 명시적으로 호출할 때만 프로그램이 오류 상태 코드를 가지고 종료하게 만들 수 있다.
  - cargo run 명령을 통해세 명령줄 처리 기능 테스트를 할 수 있다.
  ```
    cargo run 42 56
    cargo run 799459 28823 27347
    cargo run 83
    cargo run
  ```
  - 표준 라이브러리 문서는 러스트 웹사이트에서도 볼 수 있고 아래 명령으로 브라우저에서 열어 볼 수도 있다.

## 웹 서비스 만들기
  - 러스트 패키지는 라이브러리든 실행 파일이든 상관없이 모두 크레이트(crate)라고 부르는데, 키고와 crates.io가 모두 이 용어에서 파생된 이름이다.
  - cargo로 새 패키지를 만든다.
  ```
    cargo new actix-gcd  
  ```
  - cargo.toml 파일을 열고 다음과 같이 사용할 패키지들을 기재한다.
  ```
    [package]
    name = "actix-gcd"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    actix-web = "1.0.8"
    serde = { version = "1.0", features = ["derive"] }
  ```
  - serde 크레이트는 아주 간결한 웹 폼 데이터 처리 기능을 제공하는데, serde의 문서에 따르면 이 기능은 크레이트의 derive 기능을 선택해야만 쓸 수 있다.
### 러스트에 대한 정보가 아닌 웹사이트 만드는 설명이므로 추후에 다루기

## 동시성
  - 러스트에서는 메모리 오류가 없는 프로그램을 만드는 데 쓰이는 규칙이, 데이터 경합이 생기지 않는 방식으로만 메모리 공유가 가능한 스레드를 만드는 데도 동일하게 쓰인다.
    - 뮤텍스(mutex)로 공유된 데이터 구조를 변경하여 스레드의 접근 순서를 조정하는 경우, 러스트는 그 뮤텍스를 잠금 상태로 유지하고 있을 때만 해당 데이터에 접근할 수 있도록 허용하고, 작업이 끝나면 자동으로 잠금 상태를 해제한다.
    - 읽기 전용 데이터를 여러 스레드 간에 공유하려는 경우, 러스트는 실수로 데이터를 수정하는 일이 생기지 않도록 해준다.
    - 데이터 구조의 소유권을 한 스레드에서 다른 스레드로 양도하는 경우, 러스트는 원소유자가 그에 대한 모든 접근권을 실제로 포기했는지 확인한다.
  - C와 C++에서의 처리
    - 뮤텍스와 이를 통해 보호하려는 데이터 사이의 관계를 주석으로 남길 뿐이다.
    - 타입 시스템이 이문제를 해결하는 데 도움을 줄 순 있지만 실수항 개연성이 높다.
    - 소유권을 양도한 스레드가 다시는 그 데이터에 손대지 않는다는 걸 여러분이 확인해야 한다. 이를 제대로 처리하지 않으면, 이후 발생하는 프로세서의 캐시 상태 변화와 메모리 기록 작업의 횟수에 따라 다양한 증상이 나타날 수 있다.
  - 망델브로 집합(Mandelbrot set) 그리기는 스레드 간 통신 패턴이 너무 단순해서 흔히들 처치 곤란 병렬(embarrassingly parallel) 알고리즘 이라고 부른다.
## 망델브로 집합
  - 